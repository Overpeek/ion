use std::borrow::Cow;
use crate::ast::*;

//

grammar<'err>(errors: &'err mut Vec<String>);

extern {
    type Error = String;
}

match {
    // r"\s*" => { },
    // r";" => ";",
    r"[\n\r;]+" => ";",
    r"[^\S\n\r]*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}

//

pub Module: Module<'input> = {
    Stmts => Module::from(<>),
};

Stmts: Stmts<'input> = {
    ";"? <mut v: (<Stmt> ";")*> <e: Stmt?> => match e {
        Some(e) => {
            v.push(e);
            Stmts(v)
        },
        None => Stmts(v),
    },
};

pub Stmt: Stmt<'input> = {
    Expr => Stmt::Expr(<>),

    // Fntion call
    // <i:Ident> <t:Tuple> => Stmt::FnCall(FnCall::new(i, t)),

    // Named function
    <e:StmtFn> => Stmt::Assign(Assign::new(e.0, e.1)),

    // Named global function
    "global" <e:StmtFn> => Stmt::Assign(Assign::new_global(e.0, e.1)),

    // Assignment
    <i:Ident> "=" <e:Expr> => Stmt::Assign(Assign::new(i, e)),

    // Global assignment
    "global" <i:Ident> "=" <e:Expr> => Stmt::Assign(Assign::new_global(i, e)),

    // return
    "return" <e:Expr?> => Stmt::new_return(e),
};

StmtFn: (Ident<'input>, Expr<'input>) = {
    "fn" <i:Ident> "(" <p:Parameters> ")" <b:Block> => {
        (i, Expr::NamelessFn(
            Fn::new()
                .with_params(p)
                .with_random_name()
                .with_block(b)
        ))
    }
};

Expr: Expr<'input> = {
    // Nameless function declaration
    "fn(" <p:Parameters> ")" <b:Block> => {
        Expr::NamelessFn(
            Fn::new()
                .with_params(p)
                .with_random_name()
                .with_block(b)
        )
    },

    // Fntion call
    <i:Ident> <t:Tuple> => Expr::FnCall(FnCall::new(i, t)),

    // Binary expressions
    BinExpr => <>,
};

Block: Block<'input> = {
    "{" <s: Stmts> "}" => Block::from(s),
};

Tuple: Vec<Expr<'input>> = {
    "(" <v:Comma<Expr>> ")" => v,
};

Parameters = Comma<Ident>;

Comma<T>: Vec<T> = {
    <mut v: (<T> ",")*> <e:T?> => match e {
        Some(e) => {
            v.push(e);
            v
        },
        None => v,
    }
};

Ident: Ident<'input> = {
    r"[a-zA-Z_][\w_]*" => Cow::Borrowed(<>),
};

BinExpr: Expr<'input> = {
    <l:BinExpr> <op:BinOp> <r:Term> => Expr::BinExpr(BinExpr::new(l, op, r)),
    Term => <>,
};

BinOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

Term: Expr<'input> = {
    <l:Term> <op:TermOp> <r:Fact> => Expr::BinExpr(BinExpr::new(l, op, r)),
    Fact => <>,
};

TermOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

Fact: Expr<'input> = {
    "(" <e:Expr> ")" => e,
    Path => Expr::Path(<>),
    Literal => Expr::Literal(<>),
};

Path: Path<'input> = {
    <mut p: (<Ident> ".")*> <i:Ident> => {
        p.push(i);
        Path::new(p)
    },
};

Literal: Literal<'input> = {
    r#"\d[\d_]*\.\d[\d_]*"# =>? Literal::parse_float(<>),
    r#"\.\d[\d_]*"# =>? Literal::parse_float(<>),
    r#"\d[\d_]*\."# =>? Literal::parse_float(<>),

    r"\d[\d_]*" =>? Literal::parse_int(<>),
    r#""[^"]*""# => Literal::parse_str(<>),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};
